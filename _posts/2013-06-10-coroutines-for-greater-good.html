---
layout: post
title: Coroutines for the greater good
date: '2013-06-10T00:06:00.000-07:00'
summary: Coroutines in QEMU
author: Evgeny Budilovsky
tags:
- qemu
- python
- coroutines
modified_time: '2013-06-10T00:06:37.278-07:00'
blogger_id: tag:blogger.com,1999:blog-3944306087401582339.post-4123566071142498019
blogger_orig_url: http://meta-x86.blogspot.com/2013/06/coroutines-for-greater-good.html
---

Functions are the basic blocks of our daily code. This mechanism provides extremely simple and powerful abstraction. We use the stack memory as our main work space, storing there local variables and the return address. When the function returns, it pops the return address from the stack and jumps to it, allowing to continue previous function execution.<br /><br />Once the function returns all it's internal state (local variables) is destroyed and on next invocation of the function we basically need to start from scratch. We can overcome this situation by using some clever techniques but there is a better solution.<br /><br />Coroutines allow us to return from function by preserving the current context. Such coroutine can yield by passing the execution to other function which may decide to call the original function again. When this happens the execution will resume from the point of yield.<br /><br />Simple example for coroutines is the consumer-producer pattern. This use case can be implemented in the following way using coroutines:<br /><!-- HTML generated using hilite.me --><br /><div style="background: #202020; border-width: .1em .1em .1em .8em; border: solid gray; overflow: auto; padding: .2em .6em; width: auto;"><pre style="line-height: 125%; margin: 0; overflow-x: hidden; background-color: #202020; border: 0px; border-radius:0px"><span style="color: #6ab825; font-weight: bold;">void</span> <span style="color: #d0d0d0;">coroutiine__</span> <span style="color: #447fcf;">producer</span><span style="color: #d0d0d0;">()</span><br /><span style="color: #d0d0d0;">{</span><br />  <span style="color: #6ab825; font-weight: bold;">while</span> <span style="color: #d0d0d0;">(!queue_is_full(q))</span> <span style="color: #d0d0d0;">{</span><br />    <span style="color: #d0d0d0;">item_t</span> <span style="color: #d0d0d0;">*item</span> <span style="color: #d0d0d0;">=</span> <span style="color: #d0d0d0;">new_item();</span><br />    <span style="color: #d0d0d0;">queue_insert(q,</span> <span style="color: #d0d0d0;">item);</span><br />  <span style="color: #d0d0d0;">}</span><br />  <span style="color: #d0d0d0;">coroutine_yield(consumer);</span><br /><span style="color: #d0d0d0;">}</span><br /><br /><span style="color: #6ab825; font-weight: bold;">void</span> <span style="color: #d0d0d0;">coroutiine__</span> <span style="color: #447fcf;">consumer</span><span style="color: #d0d0d0;">()</span><br /><span style="color: #d0d0d0;">{</span><br />  <span style="color: #6ab825; font-weight: bold;">while</span> <span style="color: #d0d0d0;">(!queue_is_empty(q))</span> <span style="color: #d0d0d0;">{</span><br />    <span style="color: #d0d0d0;">item_t</span> <span style="color: #d0d0d0;">*item</span> <span style="color: #d0d0d0;">=</span> <span style="color: #d0d0d0;">queue_remove(q);</span><br />    <span style="color: #d0d0d0;">consume_item(item);</span><br />  <span style="color: #d0d0d0;">}</span><br />  <span style="color: #d0d0d0;">coroutine_yield(producer);</span><br /><span style="color: #d0d0d0;">}</span><br /></pre></div><br />One example of interesting usage for coroutines appears in the <a href="http://wiki.qemu.org/">qemu</a> project. Qemu is the workhorse of virtualization infrastructure and it is used extensively to provide devices emulation for hypervisors such as <a href="http://www.linux-kvm.org/page/Main_Page">kvm</a> and <a href="https://en.wikipedia.org/wiki/Xen">xen</a>.<br /><br />On Jan 2011 coroutines were <a href="http://git.qemu.org/?p=qemu.git;a=commit;h=00dccaf1f848290d979a4b1e6248281ce1b32aaa">introduced</a> into the qemu code base. The authors wanted to use the coroutines power to overcome some of the complexity involved in handling asynchronous calls. Before coroutines, many operations that could block were performed in asynchronous way using callbacks. This lead to complicated code since chunks of code were separated into single steps each implemented as separate callback. Temporary structures were used to pass parameters to callbacks and the whole picture looked complicated and unreadable.<br /><br />With introduction of coroutines, simple interface was established to invoke cooperative functions:<br /><!-- HTML generated using hilite.me --><br /><div style="background: #202020; border-width: .1em .1em .1em .8em; border: solid gray; overflow: auto; padding: .2em .6em; width: auto;"><pre style="line-height: 125%; margin: 0; overflow-x: hidden; background-color: #202020; border: 0px; border-radius:0px"><span style="color: #999999; font-style: italic;">/* Creating and starting a coroutine is easy: */</span><br />    <br /><span style="color: #d0d0d0;">coroutine</span> <span style="color: #d0d0d0;">=</span> <span style="color: #d0d0d0;">qemu_coroutine_create(my_coroutine);</span><br /><span style="color: #d0d0d0;">qemu_coroutine_enter(coroutine,</span> <span style="color: #d0d0d0;">my_data);</span><br />    <br /><span style="color: #999999; font-style: italic;">/* The coroutine then executes until it returns or yields: */</span><br />    <br /><span style="color: #6ab825; font-weight: bold;">void</span> <span style="color: #d0d0d0;">coroutine_fn</span> <span style="color: #447fcf;">my_coroutine</span><span style="color: #d0d0d0;">(</span><span style="color: #6ab825; font-weight: bold;">void</span> <span style="color: #d0d0d0;">*opaque)</span><br /><span style="color: #d0d0d0;">{</span><br />  <span style="color: #d0d0d0;">my_data_t</span> <span style="color: #d0d0d0;">*my_data</span> <span style="color: #d0d0d0;">=</span> <span style="color: #d0d0d0;">opaque;</span><br />    <br />  <span style="color: #999999; font-style: italic;">/* do some work */</span><br />  <br />  <span style="color: #d0d0d0;">qemu_coroutine_yield();</span><br />  <br />  <span style="color: #999999; font-style: italic;">/* do some more work */</span><br /><span style="color: #d0d0d0;">}</span><br /></pre></div><br />There are several implementations to the coroutines semantics inside the qemu:<br /><br /><ul><li><b>coroutine-ucontext.c</b> - implements coroutines using&nbsp;<b>swapcontext</b> system call and the&nbsp;<b>sigsetjmp/siglongjmp</b> calls. The former creates and switches to new stack and the later calls used to jump from one context to other.</li><li><b>coroutine-gthread.c</b> - uses glib threads to create abstraction of coroutines. The actual switch between coroutines stops the current thread and activates next thread which executes the cooperative task.</li><li><b>coroutine-win32.c</b> - Is the implementation on windows. Windows allows to implement coroutines easily using fibres system calls.</li><li><b>coroutine-sigaltstack.c</b> - Unlike in the ucontext implementation, here&nbsp;<b>sigaltstack</b> system call is used to switch stack and create context which is later accessed using&nbsp;<b>sigsetjmp/siglongjmp</b></li></ul><div>Different programming languages have different implementations to the coroutines abstraction. One of the best resources on the coroutines in python, is the "<a href="http://dabeaz.com/coroutines/">A Curious Course on Coroutines and Concurrency</a>" tutorial.</div>
