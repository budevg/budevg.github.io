---
layout: post
title: CPU Cache Essentials
date: '2014-06-25T09:02:00.001-07:00'
summary: This post came to my mind after watching the excellent presentation
         of&nbsp;Scott Meyers called "CPU Caches and Why You care".
         This post will try to summarize the ideas of the presentation.
author: Evgeny Budilovsky
tags:
- cpu
- cache
modified_time: '2014-06-26T12:20:47.226-07:00'
thumbnail: http://1.bp.blogspot.com/-a9wT7NnLLew/U6nCe2QGiII/AAAAAAAAB48/gzg8fuuSlf8/s72-c/georgie-pix-lightning.jpg
blogger_id: tag:blogger.com,1999:blog-3944306087401582339.post-130554521317199209
blogger_orig_url: http://meta-x86.blogspot.com/2014/06/cpu-cache-essentials.html
---

This post came to my mind after watching the excellent presentation of&nbsp;Scott Meyers called "CPU Caches and Why You care". This post will try to summarize the ideas of the presentation so if you have some spare time you can just watch the presentation on&nbsp;<a href="http://vimeo.com/97337258">video</a>.<br /><br />To emphasize importance of cpu caches in our daily work we start with 2 examples:<br /><br />The first problem is a simple traversing of 2 dimensional array. The way we can do this in c-like language is by traversing the array row by row. Alternatively we can traverse it column by column.<br /><br /><!-- HTML generated using hilite.me --><br /><div style="background: #202020; border-width: .1em .1em .1em .8em; border: solid gray; overflow: auto; padding: .2em .6em; width: auto;"><pre style="line-height: 125%; margin: 0; overflow-x: hidden; background-color: #202020; border: 0px; border-radius:0px"><span style="color: #6ab825; font-weight: bold;">uint64_t</span> <span style="color: #d0d0d0;">matrix[ROWS][COLUMNS];</span><br /><span style="color: #6ab825; font-weight: bold;">uint64_t</span> <span style="color: #d0d0d0;">i,j;</span><br /><br /><span style="color: #6ab825; font-weight: bold;">uint64_t</span> <span style="color: #d0d0d0;">ret;</span><br /><br /><span style="color: #999999; font-style: italic;">/* row by row */</span><br /><span style="color: #6ab825; font-weight: bold;">for</span> <span style="color: #d0d0d0;">(i</span> <span style="color: #d0d0d0;">=</span> <span style="color: #3677a9;">0</span><span style="color: #d0d0d0;">;</span> <span style="color: #d0d0d0;">i</span> <span style="color: #d0d0d0;">&lt;</span> <span style="color: #d0d0d0;">ROWS;</span> <span style="color: #d0d0d0;">i++)</span><br />  <span style="color: #6ab825; font-weight: bold;">for</span> <span style="color: #d0d0d0;">(j</span> <span style="color: #d0d0d0;">=</span> <span style="color: #3677a9;">0</span><span style="color: #d0d0d0;">;</span> <span style="color: #d0d0d0;">j</span> <span style="color: #d0d0d0;">&lt;</span> <span style="color: #d0d0d0;">COLUMNS;</span> <span style="color: #d0d0d0;">j++)</span><br />    <span style="color: #d0d0d0;">ret</span> <span style="color: #d0d0d0;">+=</span> <span style="color: #d0d0d0;">matrix[i][j];</span><br /><br /><span style="color: #999999; font-style: italic;">/* column by column */</span><br /><span style="color: #6ab825; font-weight: bold;">for</span> <span style="color: #d0d0d0;">(j</span> <span style="color: #d0d0d0;">=</span> <span style="color: #3677a9;">0</span><span style="color: #d0d0d0;">;</span> <span style="color: #d0d0d0;">j</span> <span style="color: #d0d0d0;">&lt;</span> <span style="color: #d0d0d0;">COLUMNS;</span> <span style="color: #d0d0d0;">j++)</span><br />  <span style="color: #6ab825; font-weight: bold;">for</span> <span style="color: #d0d0d0;">(i</span> <span style="color: #d0d0d0;">=</span> <span style="color: #3677a9;">0</span><span style="color: #d0d0d0;">;</span> <span style="color: #d0d0d0;">i</span> <span style="color: #d0d0d0;">&lt;</span> <span style="color: #d0d0d0;">ROWS;</span> <span style="color: #d0d0d0;">i++)</span><br />    <span style="color: #d0d0d0;">ret</span> <span style="color: #d0d0d0;">+=</span> <span style="color: #d0d0d0;">matrix[i][j];</span><br /></pre></div><br />Strangely for large arrays (&gt; 10MB) traversing column by column leads to terrible performance.<br /><br />The second problem is a parallel processing of some data in large array. We divide the array into X chunks and process each chunk in a separate thread. For example we want to count number of bytes which are set to 1. The following implementation doesn't scale when we run it on machines with more and more cores.<br /><br /><!-- HTML generated using hilite.me --><br /><div style="background: #202020; border-width: .1em .1em .1em .8em; border: solid gray; overflow: auto; padding: .2em .6em; width: auto;"><pre style="line-height: 125%; margin: 0; overflow-x: hidden; background-color: #202020; border: 0px; border-radius:0px"><span style="color: #6ab825; font-weight: bold;">char</span> <span style="color: #d0d0d0;">array[SIZE_10_MB];</span><br /><span style="color: #6ab825; font-weight: bold;">int</span> <span style="color: #d0d0d0;">X</span> <span style="color: #d0d0d0;">=</span> <span style="color: #d0d0d0;">NUM_OF_CORES;</span>  <br /><span style="color: #6ab825; font-weight: bold;">int</span> <span style="color: #d0d0d0;">results[X];</span><br /><br /><span style="color: #6ab825; font-weight: bold;">void</span> <span style="color: #447fcf;">chunk_worker</span><span style="color: #d0d0d0;">(</span><span style="color: #6ab825; font-weight: bold;">int</span> <span style="color: #d0d0d0;">index)</span><br /><span style="color: #d0d0d0;">{</span><br />  <span style="color: #6ab825; font-weight: bold;">int</span> <span style="color: #d0d0d0;">i;</span><br />  <span style="color: #6ab825; font-weight: bold;">int</span> <span style="color: #d0d0d0;">work_size</span> <span style="color: #d0d0d0;">=</span> <span style="color: #d0d0d0; line-height: 125%;">SIZE_10_MB</span><span style="color: #d0d0d0; line-height: 125%;">/X;</span><br />  <span style="color: #6ab825; font-weight: bold;">for</span> <span style="color: #d0d0d0;">(i</span> <span style="color: #d0d0d0;">=</span> <span style="color: #d0d0d0;">work_size</span> <span style="color: #d0d0d0;">*</span> <span style="color: #d0d0d0;">index;</span> <span style="color: #d0d0d0;">i</span> <span style="color: #d0d0d0;">&lt;</span> <span style="color: #d0d0d0;">work_size</span> <span style="color: #d0d0d0;">*</span> <span style="color: #d0d0d0;">(index</span> <span style="color: #d0d0d0;">+</span> <span style="color: #3677a9;">1</span><span style="color: #d0d0d0;">);</span> <span style="color: #d0d0d0;">i++)</span> <span style="color: #d0d0d0;">{</span><br />    <span style="color: #6ab825; font-weight: bold;">if</span> <span style="color: #d0d0d0;">(array[i]</span> <span style="color: #d0d0d0;">==</span> <span style="color: #3677a9;">1</span><span style="color: #d0d0d0;">)</span> <span style="color: #d0d0d0;">{</span><br />      <span style="color: #d0d0d0;">results[index]</span> <span style="color: #d0d0d0;">+=</span> <span style="color: #3677a9; line-height: 125%;">1</span><span style="color: #d0d0d0; line-height: 125%;">;</span><br />    <span style="color: #d0d0d0;">}</span><br />  <span style="color: #d0d0d0;">}</span><br /><span style="color: #d0d0d0;">}</span><br /></pre></div><br />This weird behavior can be explained after we learn about the cpu caches.<br /><br />CPU caches are a small amount of unusually fast memory. We have 3 types of caches in a regular CPU:<br /><ul><li>D-cache &nbsp;- cache used to store data</li><li>I-cache - cache used to store code (instructions)</li><li>TLB - cache used to store virtual to real memory address translations</li></ul><div>These caches are arranged in a typical 3 layer hierarchy:</div><br /><div style="background: #202020; border-width: .1em .1em .1em .8em; border: solid gray; overflow: auto; padding: .2em .6em; width: auto;"><pre style="line-height: 125%; margin: 0; overflow-x: hidden; background-color: #202020; border: 0px; border-radius:0px">   <span style="color: #d0d0d0;">typical</span> <span style="color: #d0d0d0;">i7-</span><span style="color: #3677a9;">9</span><span style="color: #d0d0d0;">xx</span> <span style="color: #d0d0d0;">(</span><span style="color: #3677a9;">4</span> <span style="color: #d0d0d0;">cores)</span> <span style="color: #d0d0d0;">example</span><br />   <span style="color: #d0d0d0;">|</span>     <span style="color: #d0d0d0;">|</span>           <span style="color: #d0d0d0;">|</span> <span style="color: #d0d0d0;">share</span> <span style="color: #d0d0d0;">by</span> <span style="color: #d0d0d0;">|</span>  <span style="color: #d0d0d0;">shared</span> <span style="color: #d0d0d0;">by</span> <span style="color: #d0d0d0;">|</span>            <span style="color: #d0d0d0;">|</span><br />   <span style="color: #d0d0d0;">|</span>     <span style="color: #d0d0d0;">|</span> <span style="color: #d0d0d0;">I/D</span> <span style="color: #d0d0d0;">cache</span> <span style="color: #d0d0d0;">|</span>    <span style="color: #d0d0d0;">cores</span> <span style="color: #d0d0d0;">|</span> <span style="color: #d0d0d0;">hw</span> <span style="color: #d0d0d0;">threads</span> <span style="color: #d0d0d0;">|</span> <span style="color: #d0d0d0;">latency</span>    <span style="color: #d0d0d0;">|</span><br />   <span style="color: #d0d0d0;">|</span> <span style="color: #d0d0d0;">L1</span>  <span style="color: #d0d0d0;">|</span> <span style="color: #3677a9;">32</span><span style="color: #d0d0d0;">KB/</span><span style="color: #3677a9;">32</span><span style="color: #d0d0d0;">KB</span> <span style="color: #d0d0d0;">|</span>        <span style="color: #3677a9;">1</span> <span style="color: #d0d0d0;">|</span>          <span style="color: #3677a9;">2</span> <span style="color: #d0d0d0;">|</span> <span style="color: #3677a9;">4</span> <span style="color: #d0d0d0;">cycles</span>   <span style="color: #d0d0d0;">|</span><br />   <span style="color: #d0d0d0;">|</span> <span style="color: #d0d0d0;">L2</span>  <span style="color: #d0d0d0;">|</span> <span style="color: #3677a9;">256</span><span style="color: #d0d0d0;">KB</span>     <span style="color: #d0d0d0;">|</span>        <span style="color: #3677a9;">1</span> <span style="color: #d0d0d0;">|</span>          <span style="color: #3677a9;">2</span> <span style="color: #d0d0d0;">|</span> <span style="color: #3677a9;">11</span> <span style="color: #d0d0d0;">cycles</span>  <span style="color: #d0d0d0;">|</span><br />   <span style="color: #d0d0d0;">|</span> <span style="color: #d0d0d0;">L3</span>  <span style="color: #d0d0d0;">|</span> <span style="color: #3677a9;">8</span><span style="color: #d0d0d0;">MB</span>       <span style="color: #d0d0d0;">|</span>        <span style="color: #3677a9;">4</span> <span style="color: #d0d0d0;">|</span>          <span style="color: #3677a9;">8</span> <span style="color: #d0d0d0;">|</span> <span style="color: #3677a9;">39</span> <span style="color: #d0d0d0;">cycles</span>  <span style="color: #d0d0d0;">|</span><br />   <span style="color: #d0d0d0;">|</span> <span style="color: #d0d0d0;">RAM</span> <span style="color: #d0d0d0;">|</span>           <span style="color: #d0d0d0;">|</span>          <span style="color: #d0d0d0;">|</span>            <span style="color: #d0d0d0;">|</span> <span style="color: #3677a9;">107</span> <span style="color: #d0d0d0;">cycles</span> <span style="color: #d0d0d0;">|</span><br /></pre></div><br />For example L2 is 256KB chunk of fast memory (11 cycles access time) which is used to cache both data and instructions and which is shared by 2 hardware threads on single core.<br /><br /><a href="http://1.bp.blogspot.com/-a9wT7NnLLew/U6nCe2QGiII/AAAAAAAAB48/gzg8fuuSlf8/s1600/georgie-pix-lightning.jpg" imageanchor="1" style="clear: right; float: right; margin-bottom: 1em; margin-left: 1em;"><img border="0" src="http://1.bp.blogspot.com/-a9wT7NnLLew/U6nCe2QGiII/AAAAAAAAB48/gzg8fuuSlf8/s1600/georgie-pix-lightning.jpg" height="200" width="133" /></a><i>By the way there is one type of memory that we didn't mention which can beat the performance of all these layers - the cpu registers.</i><br /><i><br /></i>Now when we talk about making your programs fast and furious, the only thing that is really matters is how well you can fit into the cache hierarchy. It won't even matter if you are using machine with 64G. In the hardware world smaller is faster. Compact code and data structures will always be fastest.<br /><br />Since access to main memory is so expensive, the hardware will bring a whole chunk of memory to put it into cache line. Typical size of cache line is 64 bytes so each time we read one byte of memory 64 bytes of data will enter our cache (and probably evict some other 64 bytes). Writing one byte of memory will <i>eventually</i> lead to writing 64 bytes of data to memory.<br /><br /><a href="http://3.bp.blogspot.com/-6GbJT6Ri-Dk/U6rumH47AyI/AAAAAAAAB-k/TEOPOv5Zn7s/s1600/computer-aplications.gif" imageanchor="1" style="clear: left; float: left; margin-bottom: 1em; margin-right: 1em;"><img border="0" src="http://3.bp.blogspot.com/-6GbJT6Ri-Dk/U6rumH47AyI/AAAAAAAAB-k/TEOPOv5Zn7s/s1600/computer-aplications.gif" height="200" width="164" /></a>One interesting thing about these cache lines is the fact that our hardware is <i>pretty smart</i> to perform prefetch of cache line once it detects forward/backward traversal.<br /><br />Thinking back about first problem of traversing matrix. It is now clear why the column by column case is having such a bad performance. When we traversing column by column we are not using each cache line effectively. In fact be bring complete cache line just to access one byte and later when the cache line is evicted from the small cache we our accessing the second byte.<br /><br />Reasoning about the coherency of the different caches becomes impossible task. Luckily we don't have to reason too much, the hardware will take care of synchronization as long as we will use proper synchronization primitives (high level mutexes, read/write barriers and etc). Unfortunately this simplification comes with <b>cost</b> - <b>TIME</b>. Your hardware will spend precious time on synchronization which will reduce the performance of your program.<br /><br /><br /><a href="http://1.bp.blogspot.com/-9wtm5TjcVvY/U6nCe-xfC8I/AAAAAAAAB5A/6f_kecOwKaY/s1600/sharing.jpg" imageanchor="1" style="clear: right; float: right; margin-bottom: 1em; margin-left: 1em;"><img border="0" src="http://1.bp.blogspot.com/-9wtm5TjcVvY/U6nCe-xfC8I/AAAAAAAAB5A/6f_kecOwKaY/s1600/sharing.jpg" height="128" width="200" /></a>Another effect of CPU caches is called "<b>False Sharing</b>". &nbsp;Suppose core 0 reads address A and core 1 writes to address A+1. Since A and A+1 occupy same cache line, hardware will need to synchronize caches by constantly invalidating the cache line and catching it back. This is exactly what happens in problem 2 where:<br /><br /><br /><br /><!-- HTML generated using hilite.me --><br /><div style="background: #202020; border-width: .1em .1em .1em .8em; border: solid gray; overflow: auto; padding: .2em .6em; width: auto;"><pre style="line-height: 125%; margin: 0; overflow-x: hidden; background-color: #202020; border: 0px; border-radius:0px"><span style="color: #d0d0d0;">results[index]</span> <span style="color: #d0d0d0;">+=</span> <span style="color: #3677a9;">1</span><span style="color: #d0d0d0;">;</span><br /></pre></div><br />invalidates the cache line each increment.<br /><br />Quick fix of using local variable to maintain result of each thread and setting them at the end leads to performance boost.<br /><br /><!-- HTML generated using hilite.me --><br /><div style="background: #202020; border-width: .1em .1em .1em .8em; border: solid gray; overflow: auto; padding: .2em .6em; width: auto;"><pre style="line-height: 125%; margin: 0; overflow-x: hidden; background-color: #202020; border: 0px; border-radius:0px"><span style="color: #6ab825; font-weight: bold;">int</span> <span style="color: #d0d0d0;">array[SIZE_10_MB];</span><br /><span style="color: #6ab825; font-weight: bold;">int</span> <span style="color: #d0d0d0;">X</span> <span style="color: #d0d0d0;">=</span> <span style="color: #d0d0d0;">NUM_OF_CORES;</span>  <br /><span style="color: #6ab825; font-weight: bold;">int</span> <span style="color: #d0d0d0;">results[X];</span><br /><br /><span style="color: #6ab825; font-weight: bold;">void</span> <span style="color: #447fcf;">chunk_worker</span><span style="color: #d0d0d0;">(</span><span style="color: #6ab825; font-weight: bold;">int</span> <span style="color: #d0d0d0;">index)</span><br /><span style="color: #d0d0d0;">{</span><br />  <span style="color: #6ab825; font-weight: bold;">int</span> <span style="color: #d0d0d0;">i;</span><br />  <span style="color: #6ab825; font-weight: bold;">int</span> <span style="color: #d0d0d0;">sum</span> <span style="color: #d0d0d0;">=</span> <span style="color: #3677a9;">0</span><span style="color: #d0d0d0;">;</span><br />  <span style="color: #6ab825; font-weight: bold;">int</span> <span style="color: #d0d0d0;">work_size</span> <span style="color: #d0d0d0;">=</span> <span style="color: #d0d0d0;">SIZE_10_MB/X;</span><br />  <span style="color: #6ab825; font-weight: bold;">for</span> <span style="color: #d0d0d0;">(i</span> <span style="color: #d0d0d0;">=</span> <span style="color: #d0d0d0;">work_size</span> <span style="color: #d0d0d0;">*</span> <span style="color: #d0d0d0;">index;</span> <span style="color: #d0d0d0;">i</span> <span style="color: #d0d0d0;">&lt;</span> <span style="color: #d0d0d0;">work_size</span> <span style="color: #d0d0d0;">*</span> <span style="color: #d0d0d0;">(index</span> <span style="color: #d0d0d0;">+</span> <span style="color: #3677a9;">1</span><span style="color: #d0d0d0;">);</span> <span style="color: #d0d0d0;">i++)</span> <span style="color: #d0d0d0;">{</span><br />    <span style="color: #6ab825; font-weight: bold;">if</span> <span style="color: #d0d0d0;">(array[i]</span> <span style="color: #d0d0d0;">==</span> <span style="color: #3677a9;">1</span><span style="color: #d0d0d0;">)</span> <span style="color: #d0d0d0;">{</span><br />      <span style="color: #d0d0d0;">sum</span> <span style="color: #d0d0d0;">+=</span> <span style="color: #3677a9;">1</span><span style="color: #d0d0d0;">;</span><br />    <span style="color: #d0d0d0;">}</span><br />  <span style="color: #d0d0d0;">}</span><br />  <span style="color: #d0d0d0;">results[index]</span> <span style="color: #d0d0d0;">=</span> <span style="color: #d0d0d0;">sum;</span><br /><span style="color: #d0d0d0;">}</span><br /></pre></div><br />To conclude here are some tips you can use to boost performance by being aware of the CPU cache tradeoffs:<br /><br /><h4>Data cache tips:</h4><ul><li>Use linear array traversal. Hardware will often optimize and pref-etch the data so that the speedup will be substantial</li><ul><li>Use as much of cache line as possible. For example in the next code when <i>else</i> clause is happening, we are throwing complete cache line which was fetched by accessing the <i>is_alive</i> member. Solution to this could be to make sure that most objects are alive.</li></ul></ul><div><!-- HTML generated using hilite.me --><br /><div style="background: #202020; border-width: .1em .1em .1em .8em; border: solid gray; overflow: auto; padding: .2em .6em; width: auto;"><pre style="line-height: 125%; margin: 0; overflow-x: hidden; background-color: #202020; border: 0px; border-radius:0px"><span style="color: #6ab825; font-weight: bold;">struct</span> <span style="color: #d0d0d0;">Obj</span> <span style="color: #d0d0d0;">{</span><br />  <span style="color: #6ab825; font-weight: bold;">bool</span> <span style="color: #d0d0d0;">is_alive;</span><br />  <span style="color: #d0d0d0;">...</span><br /><span style="color: #d0d0d0;">};</span><br /><br /><span style="color: #d0d0d0;">std::vector&lt;Object&gt;</span> <span style="color: #d0d0d0;">objs;</span><br /><br /><span style="color: #6ab825; font-weight: bold;">for</span> <span style="color: #d0d0d0;">(</span><span style="color: #6ab825; font-weight: bold;">auto</span> <span style="color: #d0d0d0;">o:</span> <span style="color: #d0d0d0;">objs)</span> <span style="color: #d0d0d0;">{</span><br />  <span style="color: #6ab825; font-weight: bold;">if</span> <span style="color: #d0d0d0;">(o.is_alive)</span><br />    <span style="color: #d0d0d0;">do_stuff(o);</span><br />  <span style="color: #6ab825; font-weight: bold;">else</span> <span style="color: #d0d0d0;">{</span><br />    <span style="color: #999999; font-style: italic;">// just thrown a cache line</span><br />  <span style="color: #d0d0d0;">}</span></pre></div></div><ul><li>Be alert for false sharing in multi-core systems</li></ul><h4>Code cache tips:</h4><div style="orphans: auto; text-align: start; text-indent: 0px; widows: auto;"><ul><li>Avoid iteration over heterogeneous sequence of objects with virtual calls. If we have sequence of heterogeneous objects the best thing would be to sort them by type so that executing virtual function of one object will lead to fetching code which can be used by the next object.</li><li>Make fast paths using branch-free sequences of code</li><li>Inline cautiously.&nbsp;</li><ul><li>Pros:&nbsp;reduce branches which will lead to speedup, compiler optimizations now possible</li><li>Cons:&nbsp;code duplication reduces code cache use</li></ul><li>Use Profile-guided Optimizations (PGO)&nbsp;and Whole Program Optimizations (WPO) tools -these are automatic tools which will help you to optimize your code</li></ul></div><br /><br /><br />
