---
layout: post
title: Building Distributed Cache with GlusterFS - not a good idea
date: '2014-02-12T14:22:00.002-08:00'
summary: Trying to build distributed cache using GlusterFS
author: Evgeny Budilovsky
tags:
- linux
- glusterfs
- storage
modified_time: '2014-02-12T14:24:24.658-08:00'
thumbnail: http://3.bp.blogspot.com/-0GIQddDAnbs/Uvvq8RTjFVI/AAAAAAAABmE/BNy25Ho_88o/s72-c/calmclearcache.jpg
blogger_id: tag:blogger.com,1999:blog-3944306087401582339.post-4742503395234786696
blogger_orig_url: http://meta-x86.blogspot.com/2014/02/building-distributed-cache-with.html
---

Cache is a popular concept. You can't survive in the cruel word of programming without using cache. Cache is inside you cpu. There is one inside you browser. Your favorite web site is serving pages from cache and you probably have one in your brain as well :)<br /><br /><div class="separator" style="clear: both; text-align: center;"></div><div class="separator" style="clear: both; text-align: center;"><a href="http://3.bp.blogspot.com/-0GIQddDAnbs/Uvvq8RTjFVI/AAAAAAAABmE/BNy25Ho_88o/s1600/calmclearcache.jpg" imageanchor="1" style="clear: left; float: left; margin-bottom: 1em; margin-right: 1em;"><img border="0" src="http://3.bp.blogspot.com/-0GIQddDAnbs/Uvvq8RTjFVI/AAAAAAAABmE/BNy25Ho_88o/s1600/calmclearcache.jpg" height="200" width="142" /></a></div><br /><br />Anyway, my mission was to build a distributed cache which can be used to speedup application X. This cache needed to be scalable and to allow extending it by adding more compute nodes. The compute nodes should be cheap amazon instances and the cache should provide very low latency (time until first byte of data arrives should be around 5ms).<br /><br />Distributed file systems are a very cool peace of technology, so naturally it seems as a good idea to use it in building this cache. After reading about Ceph vs Gluster wars I've decided to settle down on Gluster. I liked very much the idea of translators which add functionality layer by layer. Each translator is a simple unit which handles one task of complicated file system.<br /><div class="separator" style="clear: both; text-align: center;"><a href="http://4.bp.blogspot.com/-4F-eVPvrtQU/UvvryozPm9I/AAAAAAAABmQ/YSRLicOQuPQ/s1600/20120221105324808-f2df3ea3e3aeab8_250.png" imageanchor="1" style="clear: right; float: right; margin-bottom: 1em; margin-left: 1em;"><img border="0" src="http://4.bp.blogspot.com/-4F-eVPvrtQU/UvvryozPm9I/AAAAAAAABmQ/YSRLicOQuPQ/s1600/20120221105324808-f2df3ea3e3aeab8_250.png" /></a></div><br />The DHT translator in Gluster allows to distribute files between the different nodes. Later when the client wants to read file, it can locate the correct node using O(1) hash function computation and to read it directly from the node where it is located.<br /><br />Using amazon, I quickly created 5 m1.large instances and installed glusterfs. The installation is pretty easy. I used my favorite tool for repeating tasks on multiple compute nodes (<a href="http://docs.fabfile.org/">fabric</a>) and after a while installation of x nodes became as simple as running<br /><br /><div style="background: #f8f8f8; border-width: .1em .1em .1em .8em; border: solid gray; overflow: auto; padding: .2em .6em; width: auto;"><pre style="line-height: 125%; margin: 0;">&gt;&gt; fab -H hostname1,hostname2,hostnamexx -P -f gluster.py install_gluster create_volume create_mount<br /></pre></div><br />Next I created distributed glusterfs volume consisting of 5 nodes<br /><br /><div style="background: #f8f8f8; border-width: .1em .1em .1em .8em; border: solid gray; overflow: auto; padding: .2em .6em; width: auto;"><pre style="line-height: 125%; margin: 0;">&gt;&gt; gluster volume create cache hostname1:/brick1/cache hostname2:/brick1/cache hostname3:/brick1/cache hostname4:/brick1/cache hostname5:/brick1/cache<br /></pre></div><br />I modified application X code to try and use the remote cache and my algorithm became something similar to:<br /><br /><div style="background: #f8f8f8; border-width: .1em .1em .1em .8em; border: solid gray; overflow: auto; padding: .2em .6em; width: auto;"><pre style="line-height: 125%; margin: 0;">fd <span style="color: #666666;">=</span> open(<span style="color: #bb4444;">"/local_cache/file1/block1.bin"</span>, O_RDONLY);<br /><span style="color: #aa22ff; font-weight: bold;">if</span> (fd <span style="color: #666666;">==</span> <span style="color: #666666;">-1</span>) {<br />    fd <span style="color: #666666;">=</span> open(<span style="color: #bb4444;">"/gluster/file1/block1.bin"</span>, O_RDONLY);   <br />...<br />pread(fd, ....)<br /></pre></div><br />And it worked well when there was small amount of application X instances (around 10). However when the amount of application X instances was increased (8 servers, 15 application X instances on each, total of 120 applications which continuously access glusterfs through fuse interface), I've noticed that access to mounted glusterfs file system became very slow.<br /><br />Looking at latency of some of the glusterfs operation on client side (thanks good gluster has translator, called <b>debug/io-stats</b>, which can aggregate statistics), I've noticed that some of the lookup operation would take 10-20 seconds ! Basically lookup should be very lite operation, using the DHT translator the client should determine the exact server where the file should be located and then it can query it directly which will lead to distribution of stress between the 5 nodes. Each time I open the file a lookup command will be sent by gluster to determine where the file is located and later I can read it or write to it without a problem.<br /><br /><!-- HTML generated using hilite.me --><br /><div style="background: #f8f8f8; border-width: .1em .1em .1em .8em; border: solid gray; overflow: auto; padding: .2em .6em; width: auto;"><pre style="line-height: 125%; margin: 0;">Fop     Call Count    Avg-Latency  Min-Latency    Max-Latency<br />---     ----------    -----------  -----------    -----------<br />STAT            58     2133.43 us      1.00 us    62789.00 us<br />MKDIR          112  1009804.77 us     18.00 us 14452294.00 us<br />OPEN           149    22108.78 us      2.00 us  1778858.00 us<br />READ           151   160008.16 us      7.00 us  7246801.00 us<br />FLUSH          149    13178.94 us      1.00 us  1594615.00 us<br />SETXATTR      2633   232459.26 us    719.00 us 10749344.00 us<br />LOOKUP        4725   <b>641604.43 us</b>      2.00 us <b>17630043.00 us</b><br />FORGET           1           0 us         0 us           0 us<br />RELEASE        149           0 us         0 us           0 us<br />------ ----- ----- ----- ----- ----- --- -----  ----- ----- ---<br /></pre></div><br />So why are lookups take so much time ? I realized I need to look at the network level. Luckily glusterfs has <a href="https://github.com/nixpanic/gluster-wireshark-1.4">plugin for wireshark</a> which can dissect traffic and show glusterfs operations.<br /><br />Looking at the captured packets I saw that when we access file /file1/block1.bin, gluster will invoke 3 lookup operations. First for directory <b>/</b>, second for sub-directory <b>file1 </b>and then to file <b>block1.bin</b>.<br /><br />Now here are the bad news: when performing lookup for directory, gluster will broadcast lookup request to <b>all</b> nodes and then wait until all nodes will respond. In my case one of the nodes (not the one where the actual file sits) would be super busy and would respond only after 5 seconds. And so the lookup request will wait for 5 seconds without trying to continue and actually communicate with the node where the file is located. This bad situation repeats for each path directory component and leads to awful performance with lookups.<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://2.bp.blogspot.com/-2ucKmQ0RyXI/UvvwNP7UsvI/AAAAAAAABmc/fygijMCQ-Rs/s1600/1.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://2.bp.blogspot.com/-2ucKmQ0RyXI/UvvwNP7UsvI/AAAAAAAABmc/fygijMCQ-Rs/s1600/1.png" height="489" width="640" /></a></div><br /><br />Tweaking glusterfs options such as setting dht.lookup-unhashed=off, didn't help since this only relevant the file component and we still need to traverse at least two directory components until we reach the file component in the path.<br /><br />So in my opinion such behavior makes gluster very unsuitable for functioning as cache where checking if data is in cache (lookup) is a frequent method. I guess hacking gluster and modifying the DHT translator can solve the issue (and introduce <a href="https://twitter.com/irqed/status/358212928404586498">many other interesting issues</a> :)<br /><br />But this would be another interesting post ...
