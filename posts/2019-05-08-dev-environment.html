<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width">
    <link rel="icon" type="image/png" href="../static/images/pencil.ico">
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">

    <title>Evgeny Budilovsky - Let's talk about development environment</title>

    <!-- Stylesheets. -->
    <link rel="stylesheet" type="text/css" href="../style.css?v=0">

    <!-- RSS. -->
    <link rel="alternate" type="application/rss+xml" title="Evgeny Budilovsky - a personal blog" href="../rss.xml">

    <!-- Metadata. -->
    <meta name="keywords" content="Evgeny Budilovsky,blog,programming,coding,linux,functional programming,personal,homepage,kernel,storage,network,virtualization,cloud">
    <meta name="description" content="Personal home page and blog of Evgeny Budilovsky">
  </head>
  <body>
    <div id="navigation">
      <h1>Blog</h1>
      <a href="../">Home</a>
      <a href="../posts.html">Posts</a>
      <h1>Links</h1>
      <a href="http://github.com/budevg">
        <i class="fa fa-github github-color" aria-hidden="true"></i>
        GitHub
      </a>
      <a href="http://twitter.com/budevg">
        <i class="fa fa-twitter twitter-color" aria-hidden="true"></i>
        Twitter
      </a>
      <a href="https://www.linkedin.com/in/budevg">
        <i class="fa fa-linkedin linkedin-color" aria-hidden="true"></i>
        LinkedIn
      </a>
      <a type="application/rss+xml" href="../rss.xml">
        <i class="fa fa-rss rss-color" aria-hidden="true"></i>
        RSS
      </a>
    </div>

    <div id="content">
    <h1>Let's talk about development environment</h1>
<div class="soft">
    What my development environment looks like<br />
    Published on May  8, 2019 under the tag <a title="All pages tagged 'nixos'." href="../tags/nixos.html">nixos</a>, <a title="All pages tagged 'emacs'." href="../tags/emacs.html">emacs</a>, <a title="All pages tagged 'xmonad'." href="../tags/xmonad.html">xmonad</a>
</div>

<p>If you are a developer, then you probably value the software stack that you use
for your daily tasks. I am not talking about specific programming language that you
use to develop the next gen product X in your shiny startup Y. I am talking about
more basic software. The operating system, the desktop GUI environment, the code
editor and a set of productivity tools that you select to make your life easier.</p>
<p>For me the journey to build my software stack was full of tries and errors and I am
still in the middle of it waiting for new adventures.</p>
<p>The first big discovery for me was focusing on <code>Emacs</code> as the one and only editor for me.
I was familiar with <code>Emacs</code> from my lisp studies in university but then I was using
it in vanilla form without any customizations. One day I observed a power user
working in <code>XEmacs</code> (at that time <code>XEmacs</code> project was superior to the gnu <code>Emacs</code> project).
It was amazing. Working in complete state of “flow” without constantly switching windows,
clicking buttons or even moving the mouse. It was fast and powerful and it had
everything inside (terminal, file manager, man pages). I started using <code>XEmacs</code>
first with the power configuration I borrowed from that guy and later
I built my own configuration which I maintain and update to this date. Since then
the gnu <code>Emacs</code> project came back to life and I switched to gnu <code>Emacs</code> which was now
delivering new releases in much faster iterations.</p>
<p>Switching to <code>Emacs</code> gave me great power and full control of my coding workflow. I was
able to overcome any obstacles by programming <code>Emacs</code> in lisp or by searching
for extensions online. Still my desktop environment was not perfect.</p>
<p>When I started programming I was using windows desktop. Since most of my work was
on a linux environment, I was running X server from cygwin on my windows desktop
and then connecting to the linux through ssh and X forwarding <code>Emacs</code> to my windows
desktop. Later I completely switched to linux and started running ubuntu distribution
as my main desktop client both at home and at work.</p>
<p>I started to maintain repository of notes with recipes of how to install ubuntu system
from scratch with all the software I use and all the desktop customization I want.
Installing system from scratch required to walk step by step through my notes and configuring
keyboard shortcuts, fonts, display settings, installing all the programs I use and then
configuring them. At the same time ubuntu was growing and publishing new releases.
The default desktop changed to unity but I didn’t like the new design. The GUI felt heavy and
not responsive on my home pc (which was not the latest and greatest hardware). At first
I switched to gnome classic but in later releases this option was removed and I decided to
try xubuntu which was the same ubuntu distribution but with the light xfce desktop environment.</p>
<p>Working on xubuntu was ok. It was light and fast and I customized it exactly as I wanted.
At the same time I started to learn about functional programming and taking a special
interest in Haskell programming language. As I became more fluent in writing code in Haskell,
I started to explore the Haskell applications ecosystem. I stumbled upon <code>Xmonad</code>,
which is a tilling windows manager which is very customizable and can be programmed in Haskell.
It reminded me <code>Emacs</code> which is also very customizable and can be programmed in Lisp. The concept
of tiling windows manager was new for me but I have always hated the constant need to adjust and
switch between floating windows.</p>
<p>I installed <code>Xmonad</code> and configured it as new xsession on the xubuntu system. I worked with
existing <code>Xmonad</code> configurations that I’ve found on github and modified them to match my own
preferences. The result was fast and customizable desktop experience. With shortcuts and
modifications matching my work flow. Each time I wanted to change something all I needed to do
was to update my <code>Xmonad</code> configuration with several lines of Haskell code.</p>
<p>Installing new software on my dekstop was always big issue for me. I wanted to avoid “polluting”
my distribution, but at the same time I wanted to try new software. The solution was to use
virtual machines through kvm or containers through docker. One day I read about new way to manage
software packages through software called <code>Nix</code> which was very popular among haskell developers.
The idea of <code>Nix</code> is to replace the global installation locations (/lib, /bin, etc.), with per
package unique locations. These locations include unique hash which computed based on the
package dependencies and it’s contents. The bottom line is that you can easily install new versions
of software (even versions that rely on different versions of the same library - no dll hell).
Additionally it allows you to easily revert back if the new package doesn’t work or even try the
new package inside isolated environment (nix-shell).</p>
<p>There are two ways to work with <code>Nix</code>. At first I used it as additional package manager together with
the default apt/dpkg to handle ubuntu packages. But <code>Nix</code> has it’s own linux distribution called
<code>Nixos</code>. It uses <code>Nix</code> package manager to configure the software and boot linux kernel. Everything
can be configured in descriptive way using the <code>Nix</code> expression language and all the advantages
of <code>Nix</code> package manager can be applied to the whole system. For example you can switch to new
kernel by changing configuration line and if the system doesn’t work as expected you can easily
revert to old version. Switching to <code>Nixos</code> solved for me two problems. The first was the problem of
installing all my software including os from scratch in deterministic way. Now I have
configuration of all my software and after bootstrapping <code>Nixos</code> I can just apply my configuration and
I am getting all my software configured and ready. The second problem was of installing new software
without “polluting” the distribution. Since <code>Nix</code> doesn’t have global state and each package can coexist
with each other package, trying new things is easy and after I am done I can invoke nix-collect-garbage
to get rid of leftovers.</p>
<p>So today my development environment is based on <code>Emacs</code>, <code>Xmonad</code> and <code>Nixos</code>. Configuration of each component
is maintained in separate github repository</p>
<ul>
<li><a href="https://github.com/budevg/emacs-conf">emacs-conf</a></li>
<li><a href="https://github.com/budevg/xmonad-conf">xmonad-conf</a></li>
<li><a href="https://github.com/budevg/nix-conf">nix-conf</a></li>
</ul>
<p><img src="../static/files/posts/2019_05_09/emacs-xmonad-nix.png" style="width:90.0%;height:90.0%" /></p>


    <div style="clear: both"></div>

    <div id="footer">
    </div>
</div>

  </body>
</html>
